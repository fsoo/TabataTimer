/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : SSI1.c
**     Project     : TabataTimer4_2
**     Processor   : MKL26Z128VFT4
**     Component   : SSI_LDD
**     Version     : Component 01.173, Driver 01.02, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2014-10-29, 09:04, # CodeGen: 0
**     Abstract    :
**         This component "SSI_LDD" implements SLAVE part of synchronous
**         serial master-slave communication.
**     Settings    :
**          Component name                                 : SSI1
**          Device                                         : I2S0
**          Interrupt service/event                        : Enabled
**            Input interrupt                              : INT_I2S0
**            Input interrupt priority                     : medium priority
**            Output interrupt                             : INT_I2S0
**            Output interrupt priority                    : medium priority
**          Settings                                       : 
**            Mode                                         : I2S slave
**            Synchronous mode                             : Enabled
**            Gated clock mode                             : Disabled
**            Network mode                                 : Disabled
**            Two channel multiplexing                     : Disabled
**            AC97 settings                                : Disabled
**            Receiver                                     : Disabled
**            Transmitter                                  : Enabled
**              Sync to frame signal                       : Enabled
**              Width                                      : 16 bits
**              Bit 0                                      : LSB aligned
**              Data type                                  : signed 16 bits
**              Shift clock edge                           : Rising
**              Frame-sync/clock                           : Enabled
**              MSB first                                  : yes
**              Frame rate                                 : 2
**              Transmit slot mask                         : 11111111111111111111111111111111
**              HW output buffer size                      : Max buffer size
**              HW output watermark                        : 1
**              Stop in Stop mode                          : no
**              Stop in Debug mode                         : no
**              DMA                                        : Enabled
**                Version                                  : New
**                  DMA channel                            : DMAChannel_LDD
**            Master clock                                 : Output pin
**              Pin                                        : PTC4/LLWU_P8/SPI0_PCS0/UART1_TX/TPM0_CH3/I2S0_MCLK
**              Pin signal                                 : 
**              Clock rate                                 : 20.97152 MHz
**            Receive data                                 : Disabled
**            Transmit data                                : Enabled
**              Pin                                        : ADC0_SE15/TSI0_CH14/PTC1/LLWU_P6/RTC_CLKIN/I2C1_SCL/TPM0_CH0/I2S0_TXD0
**              Pin signal                                 : 
**            Receive clock                                : Disabled
**            Transmit clock                               : Enabled
**              Pin                                        : PTC3/LLWU_P7/UART1_RX/TPM0_CH2/CLKOUT/I2S0_TX_BCLK
**              Pin signal                                 : 
**              Clock idle state                           : 0
**              Direction                                  : Input
**            Receive frame sync                           : Disabled
**            Transmit frame sync                          : Enabled
**              Pin                                        : ADC0_SE11/TSI0_CH15/PTC2/I2C1_SDA/TPM0_CH1/I2S0_TX_FS
**              Pin signal                                 : 
**              Direction                                  : Input
**              Active state                               : Low
**              Frame sync length                          : one-bit
**              Frame sync initiated                       : one bit before the data
**          Initialization                                 : 
**            Enabled in init. code                        : yes
**            Auto initialization                          : no
**            Event mask                                   : 
**              OnBlockSent                                : Enabled
**              OnBlockSent1                               : Disabled
**              OnBlockReceived                            : Disabled
**              OnBlockReceived1                           : Disabled
**              OnError                                    : Enabled
**              OnReceiveFrameSync                         : Disabled
**              OnTransmitFrameSync                        : Disabled
**              OnReceiveLastSlot                          : Disabled
**              OnTransmitLastSlot                         : Disabled
**              OnReceiveComplete                          : Disabled
**              OnTransmitComplete                         : Disabled
**              OnAC97TagUpdated                           : Disabled
**              OnAC97CommandAddressUpdated                : Disabled
**              OnAC97CommandDataUpdated                   : Disabled
**          CPU clock/configuration selection              : 
**            Clock configuration 0                        : This component enabled
**            Clock configuration 1                        : This component disabled
**            Clock configuration 2                        : This component disabled
**            Clock configuration 3                        : This component disabled
**            Clock configuration 4                        : This component disabled
**            Clock configuration 5                        : This component disabled
**            Clock configuration 6                        : This component disabled
**            Clock configuration 7                        : This component disabled
**     Contents    :
**         Init            - LDD_TDeviceData* SSI1_Init(LDD_TUserData *UserDataPtr);
**         Deinit          - void SSI1_Deinit(LDD_TDeviceData *DeviceDataPtr);
**         EnableTransfer  - LDD_TError SSI1_EnableTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         DisableTransfer - LDD_TError SSI1_DisableTransfer(LDD_TDeviceData *DeviceDataPtr,...
**         SendBlock       - LDD_TError SSI1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData...
**         GetSentDataNum  - uint16_t SSI1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr);
**         GetError        - LDD_TError SSI1_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_SSI_TError...
**
**     Copyright : 1997 - 2014 Freescale Semiconductor, Inc. 
**     All Rights Reserved.
**     
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**     
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**     
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**     
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**     
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**     
**     http: www.freescale.com
**     mail: support@freescale.com
** ###################################################################*/
/*!
** @file SSI1.c
** @version 01.02
** @brief
**         This component "SSI_LDD" implements SLAVE part of synchronous
**         serial master-slave communication.
*/         
/*!
**  @addtogroup SSI1_module SSI1 module documentation
**  @{
*/         

/* MODULE SSI1. */
/*lint -save  -e926 -e927 -e928 -e929 Disable MISRA rule (11.4) checking. */

#include "Events.h"
#include "SSI1.h"
#include "FreeRTOS.h" /* FreeRTOS interface */

#define HW_TX_BUFFER_SIZE 1U
#define HW_TX_WATERMARK 1U

/* These constants contain pin masks */
#define SSI1_AVAILABLE_PIN_MASK (LDD_SSI_OUTPUT_PIN | LDD_SSI_TX_CLK_PIN | LDD_SSI_TX_FS_PIN | LDD_SSI_MCLK_PIN)
#define AVAILABLE_TX_SLOT_MASK 0x03UL


typedef struct {
  LDD_SSI_TSectionMask EnTransfer;     /* Enable/Disable mask of Rx and Tx device transfer */
  LDD_SSI_TError ErrFlag;              /* Error flags */
  uint8_t *OutDataPtr;                 /* The buffer pointer for data to be transmitted */
  uint16_t OutDataNumReq;              /* The counter of data words to be send */
  LDD_TDeviceData *DmaTxTransferPtr[1U]; /* DMA Tx transfer device data structure */
  LDD_TUserData *UserData;             /* User device data structure */
} SSI1_TDeviceData;                    /* Device data structure type */

typedef SSI1_TDeviceData* SSI1_TDeviceDataPtr ; /* Pointer to the device data structure. */

/* {FreeRTOS RTOS Adapter} Static object used for simulation of dynamic driver memory allocation */
static SSI1_TDeviceData DeviceDataPtr__DEFAULT_RTOS_ALLOC;
/* {FreeRTOS RTOS Adapter} Global variable used for passing a parameter into ISR */
static SSI1_TDeviceDataPtr INT_I2S0__BAREBOARD_RTOS_ISRPARAM;
/* Internal method prototypes */
/*
** ===================================================================
**     Method      :  SSI1_Init (component SSI_LDD)
*/
/*!
**     @brief
**         Initializes the device. Allocates memory for the device data
**         structure, allocates interrupt vectors and sets interrupt
**         priority, sets pin routing, sets timing, etc.
**         If the "Enable in init. code" is set to "yes" value then the
**         device is also enabled(see the description of the Enable()
**         method). In this case the Enable() method is not necessary
**         and needn't to be generated. 
**         This method can be called only once. Before the second call
**         of Init() the Deinit() must be called first.
**     @param
**         UserDataPtr     - Pointer to the user or
**                           RTOS specific data. This pointer will be
**                           passed as an event or callback parameter.
**     @return
**                         - Device data structure pointer.
*/
/* ===================================================================*/
LDD_TDeviceData* SSI1_Init(LDD_TUserData *UserDataPtr)
{
  /* Allocate LDD device structure */
  SSI1_TDeviceData *DeviceDataPtr;

  /* {FreeRTOS RTOS Adapter} Driver memory allocation: Dynamic allocation is simulated by a pointer to the static object */
  DeviceDataPtr = &DeviceDataPtr__DEFAULT_RTOS_ALLOC;
  /* Init and configure Tx DMATransfer (inherited component SSI1_TxDMA) */
  DeviceDataPtr->DmaTxTransferPtr[0U] = SSI1_TxDMA_Init((LDD_TUserData *)DeviceDataPtr); /* Initialize Tx DMATransfer inherited component */
  if (DeviceDataPtr->DmaTxTransferPtr[0U] == NULL) { /* DMATransfer inherited component initialized successfully? */
    return NULL;                       /* If no, return with NULL. */
  }
  DeviceDataPtr->UserData = UserDataPtr; /* Store the RTOS device structure */
  /* Interrupt vector(s) allocation */
  /* {FreeRTOS RTOS Adapter} Set interrupt vector: IVT is static, ISR parameter is passed by the global variable */
  INT_I2S0__BAREBOARD_RTOS_ISRPARAM = DeviceDataPtr;
  DeviceDataPtr->EnTransfer = 0x00U;   /* Clear enable receiver and transmitter flags */
  DeviceDataPtr->ErrFlag = 0x00U;      /* Clear error flags */
  /* Clear the transmit counters and pointer */
  DeviceDataPtr->OutDataNumReq = 0x00U; /* Clear the counter of data words to be send by SendBlock() */
  DeviceDataPtr->OutDataPtr = NULL;    /* Clear the buffer pointer for data to be transmitted */
  /* SIM_SCGC6: I2S=1 */
  SIM_SCGC6 |= SIM_SCGC6_I2S_MASK;
  /* Interrupt vector(s) priority setting */
  /* NVIC_IPR5: PRI_23=0x80 */
  NVIC_IPR5 = (uint32_t)((NVIC_IPR5 & (uint32_t)~(uint32_t)(
               NVIC_IP_PRI_23(0x7F)
              )) | (uint32_t)(
               NVIC_IP_PRI_23(0x80)
              ));
  /* NVIC_ISER: SETENA|=0x00800000 */
  NVIC_ISER |= NVIC_ISER_SETENA(0x00800000);
  /* PORTC_PCR1: ISF=0,MUX=6 */
  PORTC_PCR1 = (uint32_t)((PORTC_PCR1 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x01)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x06)
               ));
  /* PORTC_PCR3: ISF=0,MUX=6 */
  PORTC_PCR3 = (uint32_t)((PORTC_PCR3 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x01)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x06)
               ));
  /* PORTC_PCR2: ISF=0,MUX=6 */
  PORTC_PCR2 = (uint32_t)((PORTC_PCR2 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x01)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x06)
               ));
  /* PORTC_PCR4: ISF=0,MUX=5 */
  PORTC_PCR4 = (uint32_t)((PORTC_PCR4 & (uint32_t)~(uint32_t)(
                PORT_PCR_ISF_MASK |
                PORT_PCR_MUX(0x02)
               )) | (uint32_t)(
                PORT_PCR_MUX(0x05)
               ));
  /* I2S0_TCSR: TE=0,STOPE=0,DBGE=0,BCE=0,??=0,??=0,FR=1,SR=0,??=0,??=0,??=1,WSF=1,SEF=1,FEF=0,FWF=0,??=0,??=0,??=0,??=0,WSIE=0,SEIE=0,FEIE=0,FWIE=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FWDE=0,??=0 */
  I2S0_TCSR = I2S_TCSR_FR_MASK |
              I2S_TCSR_WSF_MASK |
              I2S_TCSR_SEF_MASK |
              0x00200000U;             /* Disable transmitter */
  while ((I2S0_TCSR & I2S_TCSR_TE_MASK) != 0U) {} /* Wait for transmit disable*/
  /* I2S0_RCSR: RE=0,STOPE=0,DBGE=0,BCE=0,??=0,??=0,FR=1,SR=0,??=0,??=0,??=1,WSF=1,SEF=1,FEF=0,FWF=0,??=0,??=0,??=0,??=0,WSIE=0,SEIE=0,FEIE=0,FWIE=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FWDE=0,??=0 */
  I2S0_RCSR = I2S_RCSR_FR_MASK |
              I2S_RCSR_WSF_MASK |
              I2S_RCSR_SEF_MASK |
              0x00200000U;             /* Disable receiver */
  while ((I2S0_RCSR & I2S_RCSR_RE_MASK) != 0U) {} /* Wait for receive disable*/
  /* I2S0_MCR: MOE=0 */
  I2S0_MCR &= (uint32_t)~(uint32_t)(I2S_MCR_MOE_MASK); /* Disable MCLK divider */
  while ((I2S0_MCR & I2S_MCR_MOE_MASK) != 0U) {} /* Wait for MCLK disable*/
  /* I2S0_MDR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FRACT=0,DIVIDE=0 */
  I2S0_MDR = (I2S_MDR_FRACT(0x00) | I2S_MDR_DIVIDE(0x00)); /* Configure Mclk divide ratio */
  /* I2S0_MCR: DUF=0,MOE=1,??=0,??=0,??=0,??=0,MICS=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  I2S0_MCR = (I2S_MCR_MOE_MASK | I2S_MCR_MICS(0x00)); /* Configure Mclk source */
  /* I2S0_TCR2: SYNC=0,BCS=0,BCI=0,MSEL=0,BCP=0,BCD=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DIV=0 */
  I2S0_TCR2 = (I2S_TCR2_SYNC(0x00) | I2S_TCR2_MSEL(0x00) | I2S_TCR2_DIV(0x00)); /* Set Tx configuration 2 register */
  /* I2S0_RCR2: SYNC=0,BCS=0,BCI=0,MSEL=0,BCP=0,BCD=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DIV=0 */
  I2S0_RCR2 = (I2S_RCR2_SYNC(0x00) | I2S_RCR2_MSEL(0x00) | I2S_RCR2_DIV(0x00)); /* Set Rx Configuration 2 register */
  /* I2S0_TCR3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,TCE=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,WDFL=0 */
  I2S0_TCR3 = I2S_TCR3_TCE_MASK;       /* Set Tx configuration 3 register */
  /* I2S0_RCR3: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,RCE=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,WDFL=0 */
  I2S0_RCR3 = 0x00U;                   /* Set Rx configuration 3 register */
  /* I2S0_TCR4: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FRSZ=1,??=0,??=0,??=0,SYWD=0,??=0,??=0,??=0,MF=1,FSE=1,??=0,FSP=1,FSD=0 */
  I2S0_TCR4 = I2S_TCR4_FRSZ_MASK |
              I2S_TCR4_SYWD(0x00) |
              I2S_TCR4_MF_MASK |
              I2S_TCR4_FSE_MASK |
              I2S_TCR4_FSP_MASK;       /* Set Tx configuration 4 register */
  /* I2S0_RCR4: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FRSZ=0,??=0,??=0,??=0,SYWD=0,??=0,??=0,??=0,MF=0,FSE=0,??=0,FSP=0,FSD=0 */
  I2S0_RCR4 = I2S_RCR4_SYWD(0x00);     /* Set Rx configuration 4 register */
  /* I2S0_TCR5: ??=0,??=0,??=0,WNW=0x0F,??=0,??=0,??=0,W0W=0x0F,??=0,??=0,??=0,FBT=0x0F,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  I2S0_TCR5 = (I2S_TCR5_WNW(0x0F) | I2S_TCR5_W0W(0x0F) | I2S_TCR5_FBT(0x0F)); /* Set Tx configuration 5 register */
  /* I2S0_RCR5: ??=0,??=0,??=0,WNW=0,??=0,??=0,??=0,W0W=0,??=0,??=0,??=0,FBT=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  I2S0_RCR5 = (I2S_RCR5_WNW(0x00) | I2S_RCR5_W0W(0x00) | I2S_RCR5_FBT(0x00)); /* Set Rx configuration 5 register */
  /* I2S0_TCSR: TE=0,STOPE=1,DBGE=1,BCE=0,??=0,??=0,FR=0,SR=0,??=0,??=0,??=0,WSF=0,SEF=0,FEF=0,FWF=0,??=0,??=0,??=0,??=0,WSIE=0,SEIE=1,FEIE=1,FWIE=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FWDE=1,??=0 */
  I2S0_TCSR = I2S_TCSR_STOPE_MASK |
              I2S_TCSR_DBGE_MASK |
              I2S_TCSR_SEIE_MASK |
              I2S_TCSR_FEIE_MASK |
              I2S_TCSR_FWDE_MASK;      /* Set Tx control register */
  /* I2S0_RCSR: RE=0,STOPE=0,DBGE=0,BCE=0,??=0,??=0,FR=0,SR=0,??=0,??=0,??=0,WSF=0,SEF=0,FEF=0,FWF=0,??=0,??=0,??=0,??=0,WSIE=0,SEIE=0,FEIE=0,FWIE=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,FWDE=0,??=0 */
  I2S0_RCSR = 0x00U;                   /* Set Rx control register */
  /* Registration of the device structure */
  PE_LDD_RegisterDeviceStructure(PE_LDD_COMPONENT_SSI1_ID,DeviceDataPtr);
  return ((LDD_TDeviceData *)DeviceDataPtr); /* Return pointer to the data data structure */
}

/*
** ===================================================================
**     Method      :  SSI1_Deinit (component SSI_LDD)
*/
/*!
**     @brief
**         This method deinitializes the device. It switches off the
**         device, frees the device data structure memory, interrupts
**         vectors, etc.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
*/
/* ===================================================================*/
void SSI1_Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  /* Disable Tx interrupts */
  I2S_PDD_DisableTxInterrupt(I2S0_BASE_PTR,(I2S_PDD_SYNC_ERROR_INT|I2S_PDD_FIFO_ERROR_INT));
  do {
    I2S_PDD_EnableTxDevice(I2S0_BASE_PTR,PDD_DISABLE); /* Disable transmitter */
  } while(I2S_PDD_GetTxDeviceState(I2S0_BASE_PTR) == PDD_ENABLE); /* Wait until the end of the current frame. */
  I2S_PDD_EnableTxDataChannel(I2S0_BASE_PTR, PDD_DISABLE); /* Disable Tx data channel */
  I2S_PDD_ClearTxInterruptFlags(I2S0_BASE_PTR, I2S_PDD_ALL_INT_FLAG); /* Clear all Tx interrupt flags */
  SSI1_TxDMA_Deinit(((SSI1_TDeviceData *)DeviceDataPtr)->DmaTxTransferPtr[0U]); /* Deinitialize Tx DMATransfer inherited component SSI1_TxDMA */
  /* Restoring the interrupt vector */
  /* {FreeRTOS RTOS Adapter} Restore interrupt vector: IVT is static, no code is generated */
  /* Unregistration of the device structure */
  PE_LDD_UnregisterDeviceStructure(PE_LDD_COMPONENT_SSI1_ID);
  /* Deallocation of the device structure */
  /* {FreeRTOS RTOS Adapter} Driver memory deallocation: Dynamic allocation is simulated, no deallocation code is generated */
  /* SIM_SCGC6: I2S=0 */
  SIM_SCGC6 &= (uint32_t)~(uint32_t)(SIM_SCGC6_I2S_MASK);
}

/*
** ===================================================================
**     Method      :  SSI1_EnableTransfer (component SSI_LDD)
*/
/*!
**     @brief
**         This method enables data transfer. Before first call use the
**         <SendBlock> method to prepare data for sending or/and
**         <ReceiveBlock> method to prepare space for received data.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         SectionMask     - Section mask. Following
**                           status masks defined in PE_Types.h:
**                           LDD_SSI_RECEIVER - Receive section of the
**                           device.
**                           LDD_SSI_TRANSMITTER - Transmit section of
**                           the device.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_PARAM_MASK - Invalid section mask
**                           parameter
*/
/* ===================================================================*/
LDD_TError SSI1_EnableTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_SSI_TSectionMask SectionMask)
{
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  if ((SectionMask & LDD_SSI_TRANSMITTER) != 0x00U) { /* Enable required sections */
    I2S_PDD_EnableTxDataChannel(I2S0_BASE_PTR, PDD_ENABLE); /* Enable Tx data channel */
    I2S_PDD_ClearTxInterruptFlags(I2S0_BASE_PTR, I2S_PDD_ALL_INT_FLAG); /* Clear all Tx interrupt flags */
    ((SSI1_TDeviceDataPtr)DeviceDataPtr)->EnTransfer |= LDD_SSI_TRANSMITTER; /* Set enable transmitter flag */
    /* Enable Tx interrupts */
    I2S_PDD_EnableTxInterrupt(I2S0_BASE_PTR,(I2S_PDD_SYNC_ERROR_INT|I2S_PDD_FIFO_ERROR_INT));
    I2S_PDD_EnableTxDevice(I2S0_BASE_PTR,PDD_ENABLE); /* Enable transmitter */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  SSI1_DisableTransfer (component SSI_LDD)
*/
/*!
**     @brief
**         This method disables data transfer.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         SectionMask     - Section mask. The
**                           component event masks are defined in the
**                           PE_Types.h file.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - The device doesn't work in the
**                           active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_PARAM_MASK - Invalid section mask
**                           parameter
*/
/* ===================================================================*/
LDD_TError SSI1_DisableTransfer(LDD_TDeviceData *DeviceDataPtr, LDD_SSI_TSectionMask SectionMask)
{
  (void)DeviceDataPtr;                 /* Parameter is not used, suppress unused argument warning */
  if ((SectionMask & LDD_SSI_TRANSMITTER) != 0x00U) { /* Disable required sections */
    /* Disable Tx interrupts */
    I2S_PDD_DisableTxInterrupt(I2S0_BASE_PTR,(I2S_PDD_SYNC_ERROR_INT|I2S_PDD_FIFO_ERROR_INT));
    do {
      I2S_PDD_EnableTxDevice(I2S0_BASE_PTR,PDD_DISABLE); /* Disable transmitter */
    } while(I2S_PDD_GetTxDeviceState(I2S0_BASE_PTR) == PDD_ENABLE); /* Wait until the end of the current frame. */
    I2S_PDD_EnableTxDataChannel(I2S0_BASE_PTR, PDD_DISABLE); /* Disable Tx data channel */
    I2S_PDD_ClearTxInterruptFlags(I2S0_BASE_PTR, I2S_PDD_ALL_INT_FLAG); /* Clear all Tx interrupt flags */
    I2S_PDD_EnableTxSoftwareReset(I2S0_BASE_PTR, PDD_ENABLE); /* Reset transmitter */
    I2S_PDD_EnableTxSoftwareReset(I2S0_BASE_PTR, PDD_DISABLE);
    ((SSI1_TDeviceDataPtr)DeviceDataPtr)->EnTransfer &= (LDD_SSI_TSectionMask)(~LDD_SSI_TRANSMITTER); /* Clear enable transmitter flag */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  SSI1_SendBlock (component SSI_LDD)
*/
/*!
**     @brief
**         This method sends a block of characters. The method returns
**         ERR_BUSY when the previous block transmission is not
**         completed. This method should be called before the first
**         call of the <EnableTransfer> method with LDD_SSI_TRANSMITTER
**         used in the second parameter, for more info please see the
**         <Typical Usage> page in help. The method
**         <CancelBlockTransmission> can be used to cancel a transmit
**         operation.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         BufferPtr       - Pointer to the block of data
**                           to send.
**     @param
**         Size            - Size of the data block.
**     @return
**                         - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active clock configuration
**                           ERR_DISABLED - Component is disabled
**                           ERR_BUSY - The previous transmit request is
**                           pending
**                           ERR_PARAM_SIZE - Size of the data block is
**                           out of range
*/
/* ===================================================================*/
LDD_TError SSI1_SendBlock(LDD_TDeviceData *DeviceDataPtr, LDD_TData *BufferPtr, uint16_t Size)
{
  if (((SSI1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq != 0x00U) { /* Is the previous transmit operation pending? */
    return ERR_BUSY;                   /* If yes then error */
  }
  /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS Adapter property) */
  taskENTER_CRITICAL();
  ((SSI1_TDeviceDataPtr)DeviceDataPtr)->OutDataNumReq = Size; /* Set the counter of data words to be sent. */
  (void)SSI1_TxDMA_SetSourceAddress(((SSI1_TDeviceData *)DeviceDataPtr)->DmaTxTransferPtr[0U], (LDD_DMA_TData*)BufferPtr); /* Set source DMA address */
  (void)SSI1_TxDMA_SetRequestCount(((SSI1_TDeviceData *)DeviceDataPtr)->DmaTxTransferPtr[0U], (LDD_DMA_TRequestCount)(Size / 0x01U));
  (void)SSI1_TxDMA_EnableRequest(((SSI1_TDeviceData *)DeviceDataPtr)->DmaTxTransferPtr[0U]); /* Enable Tx DMA channel request */
  /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS Adapter property) */
  taskEXIT_CRITICAL();
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  SSI1_GetSentDataNum (component SSI_LDD)
*/
/*!
**     @brief
**         Returns the number of sent characters. This method is
**         available only if method SendBlock is enabled.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @return
**                         - The number of characters in the output
**                           buffer.
*/
/* ===================================================================*/
uint16_t SSI1_GetSentDataNum(LDD_TDeviceData *DeviceDataPtr)
{
  return SSI1_TxDMA_GetTransferredDataSize(((SSI1_TDeviceDataPtr)DeviceDataPtr)->DmaTxTransferPtr[0U]); /* Get DMA transferred bytes number. */
}

/*
** ===================================================================
**     Method      :  SSI1_GetError (component SSI_LDD)
*/
/*!
**     @brief
**         This method return a set of asserted flags. The flags are
**         accumulated in the set. After calling this method the set is
**         returned and cleared.
**     @param
**         DeviceDataPtr   - Device data structure
**                           pointer returned by <Init> method.
**     @param
**         ErrorPtr        - A pointer to the returned set of
**                           error flags:
**                           LDD_SSI_RX_OVERFLOW - Receiver overflow
**                           LDD_SSI_RX_OVERFLOW_1 - Receiver overflow 1
**                           (only if HW has second channel)
**                           LDD_SSI_TX_UNDERFLOW - Transmitter
**                           underflow
**                           LDD_SSI_TX_UNDERFLOW_1 - Transmitter
**                           underflow 1 (only if HW has second channel)
**     @return
**                         - Error code (if GetError did not succeed),
**                           possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active clock configuration
**                           ERR_DISABLED - Component is disabled
*/
/* ===================================================================*/
LDD_TError SSI1_GetError(LDD_TDeviceData *DeviceDataPtr, LDD_SSI_TError *ErrorPtr)
{
  /* {FreeRTOS RTOS Adapter} Critical section begin (RTOS function call is defined by FreeRTOS RTOS Adapter property) */
  taskENTER_CRITICAL();
  *ErrorPtr = ((SSI1_TDeviceDataPtr)DeviceDataPtr)->ErrFlag;
  ((SSI1_TDeviceDataPtr)DeviceDataPtr)->ErrFlag = 0x00U; /* Reset error flags */
  /* {FreeRTOS RTOS Adapter} Critical section ends (RTOS function call is defined by FreeRTOS RTOS Adapter property) */
  taskEXIT_CRITICAL();
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  SSI1_RxTxInterrupt (component SSI_LDD)
**
**     Description :
**         The ISR function handling the device receive/transmit 
**         interrupt.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
PE_ISR(SSI1_RxTxInterrupt)
{
  /* {FreeRTOS RTOS Adapter} ISR parameter is passed through the global variable */
  SSI1_TDeviceDataPtr DeviceDataPrv = INT_I2S0__BAREBOARD_RTOS_ISRPARAM;
  uint32_t StatRegTx = I2S_PDD_GetTxInterruptFlags(I2S0_BASE_PTR); /* Read status register */
  if ((StatRegTx & (I2S_PDD_FIFO_ERROR_FLAG | I2S_PDD_SYNC_ERROR_FLAG)) != 0U) { /* Is any error flag set? */
    I2S_PDD_ClearTxInterruptFlags(I2S0_BASE_PTR, (I2S_PDD_FIFO_ERROR_FLAG | I2S_PDD_SYNC_ERROR_FLAG)); /* Clear error flags */
    if ((StatRegTx & I2S_PDD_FIFO_ERROR_FLAG) != 0U) { /* Is Tx FIFO has underrun? */
      DeviceDataPrv->ErrFlag |= LDD_SSI_TX_UNDERFLOW; /* If yes then set the flag */
    }
    if ((StatRegTx & I2S_PDD_SYNC_ERROR_FLAG) != 0U) { /* Is Rx Frame sync error detected? */
      DeviceDataPrv->ErrFlag |= LDD_SSI_TX_SYNC_ERROR; /* If yes then set the flag */
    }
    SSI1_OnError(DeviceDataPrv->UserData);
  }
  (void)DeviceDataPrv;                 /* Parameter is not used, suppress unused argument warning */
  I2S_PDD_ClearRxInterruptFlags(I2S0_BASE_PTR, I2S_PDD_ALL_INT_FLAG); /* Clear Rx flags */
  I2S_PDD_DisableRxInterrupt(I2S0_BASE_PTR, (I2S_PDD_WORD_START_INT|I2S_PDD_SYNC_ERROR_INT|I2S_PDD_FIFO_ERROR_INT|I2S_PDD_FIFO_WARNING_INT
));
}

/*
** ===================================================================
**     Method      :  SSI1_SSI1_TxDMA_OnComplete (component SSI_LDD)
**
**     Description :
**         Called at the end of a DMA transfer. If the Half complete 
**         property in initialization section is anabled, this event is 
**         also called when current major iteration count reaches the 
**         halfway point. See SetEventMask() and GetEventMask() methods. 
**         This event is enabled only if Interrupts property in Channel 
**         select section is enabled. The event services the event of the 
**         inherited component and eventually invokes other events.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SSI1_TxDMA_OnComplete(LDD_TUserData *UserDataPtr)
{
  SSI1_TDeviceData *DeviceDataPrv = (SSI1_TDeviceData *)UserDataPtr;

  DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of data words to be sent. */
  SSI1_OnBlockSent(DeviceDataPrv->UserData);
}

/*
** ===================================================================
**     Method      :  SSI1_SSI1_TxDMA_OnError (component SSI_LDD)
**
**     Description :
**         Called when error in channel settings is detected. See 
**         SetEventMask() and GetEventMask() methods. This event is 
**         enabled only if Interrupts property in Channel select section 
**         is enabled. The event services the event of the inherited 
**         component and eventually invokes other events.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void SSI1_TxDMA_OnError(LDD_TUserData *UserDataPtr)
{
  SSI1_TDeviceData *DeviceDataPrv = (SSI1_TDeviceData *)UserDataPtr;

  DeviceDataPrv->OutDataNumReq = 0x00U; /* Clear the counter of data words to be sent. */
  DeviceDataPrv->ErrFlag |= LDD_SSI_TX_DMA_ERROR; /* If yes then set the flag */
  SSI1_OnError(DeviceDataPrv->UserData);
}

/*lint -restore Enable MISRA rule (11.4) checking. */
/* END SSI1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.3 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
